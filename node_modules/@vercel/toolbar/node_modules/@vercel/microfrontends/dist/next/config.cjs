"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/next/config/index.ts
var config_exports = {};
__export(config_exports, {
  withMicrofrontends: () => withMicrofrontends
});
module.exports = __toCommonJS(config_exports);

// src/bin/check-proxy.ts
function displayLocalProxyInfo(port) {
  const { MFE_PROXY_MESSAGE_PRINTED, TURBO_TASK_HAS_MFE_PROXY } = process.env;
  if (TURBO_TASK_HAS_MFE_PROXY === "true" && MFE_PROXY_MESSAGE_PRINTED !== "true") {
    process.env.MFE_PROXY_MESSAGE_PRINTED = "true";
    console.log(`Microfrontends Proxy running on http://localhost:${port}`);
  }
}

// src/config/microfrontends/server/index.ts
var import_node_fs8 = __toESM(require("fs"), 1);
var import_node_path9 = require("path");

// src/config/overrides/constants.ts
var OVERRIDES_COOKIE_PREFIX = "vercel-micro-frontends-override";
var OVERRIDES_ENV_COOKIE_PREFIX = `${OVERRIDES_COOKIE_PREFIX}:env:`;

// src/config/overrides/is-override-cookie.ts
function isOverrideCookie(cookie) {
  return Boolean(cookie.name?.startsWith(OVERRIDES_COOKIE_PREFIX));
}

// src/config/overrides/get-override-from-cookie.ts
function getOverrideFromCookie(cookie) {
  if (!isOverrideCookie(cookie) || !cookie.value)
    return;
  return {
    application: cookie.name.replace(OVERRIDES_ENV_COOKIE_PREFIX, ""),
    host: cookie.value
  };
}

// src/config/overrides/parse-overrides.ts
function parseOverrides(cookies) {
  const overridesConfig = { applications: {} };
  cookies.forEach((cookie) => {
    const override = getOverrideFromCookie(cookie);
    if (!override)
      return;
    overridesConfig.applications[override.application] = {
      environment: { host: override.host }
    };
  });
  return overridesConfig;
}

// src/config/errors.ts
var MicrofrontendError = class extends Error {
  constructor(message, opts) {
    super(message, { cause: opts?.cause });
    this.name = "MicrofrontendsError";
    this.source = opts?.source ?? "@vercel/microfrontends";
    this.type = opts?.type ?? "unknown";
    this.subtype = opts?.subtype;
    Error.captureStackTrace(this, MicrofrontendError);
  }
  isKnown() {
    return this.type !== "unknown";
  }
  isUnknown() {
    return !this.isKnown();
  }
  /**
   * Converts an error to a MicrofrontendsError.
   * @param original - The original error to convert.
   * @returns The converted MicrofrontendsError.
   */
  static convert(original, opts) {
    if (opts?.fileName) {
      const err = MicrofrontendError.convertFSError(original, opts.fileName);
      if (err) {
        return err;
      }
    }
    if (original.message.includes(
      "Code generation from strings disallowed for this context"
    )) {
      return new MicrofrontendError(original.message, {
        type: "config",
        subtype: "unsupported_validation_env",
        source: "ajv"
      });
    }
    return new MicrofrontendError(original.message);
  }
  static convertFSError(original, fileName) {
    if (original instanceof Error && "code" in original) {
      if (original.code === "ENOENT") {
        return new MicrofrontendError(`Could not find "${fileName}"`, {
          type: "config",
          subtype: "unable_to_read_file",
          source: "fs"
        });
      }
      if (original.code === "EACCES") {
        return new MicrofrontendError(
          `Permission denied while accessing "${fileName}"`,
          {
            type: "config",
            subtype: "invalid_permissions",
            source: "fs"
          }
        );
      }
    }
    if (original instanceof SyntaxError) {
      return new MicrofrontendError(
        `Failed to parse "${fileName}": Invalid JSON format.`,
        {
          type: "config",
          subtype: "invalid_syntax",
          source: "fs"
        }
      );
    }
    return null;
  }
  /**
   * Handles an unknown error and returns a MicrofrontendsError instance.
   * @param err - The error to handle.
   * @returns A MicrofrontendsError instance.
   */
  static handle(err, opts) {
    if (err instanceof MicrofrontendError) {
      return err;
    }
    if (err instanceof Error) {
      return MicrofrontendError.convert(err, opts);
    }
    if (typeof err === "object" && err !== null) {
      if ("message" in err && typeof err.message === "string") {
        return MicrofrontendError.convert(new Error(err.message), opts);
      }
    }
    return new MicrofrontendError("An unknown error occurred");
  }
};

// src/config/microfrontends-config/utils/get-config-from-env.ts
function getConfigStringFromEnv() {
  const config = process.env.MFE_CONFIG;
  if (!config) {
    throw new MicrofrontendError(`Missing "MFE_CONFIG" in environment.`, {
      type: "config",
      subtype: "not_found_in_env"
    });
  }
  return config;
}

// src/config/microfrontends-config/isomorphic/index.ts
var import_jsonc_parser = require("jsonc-parser");

// src/config/schema/utils/is-main-config.ts
function isMainConfig(c) {
  return !("partOf" in c);
}

// src/config/schema/utils/is-default-app.ts
function isDefaultApp(a) {
  return !("routing" in a);
}

// src/config/microfrontends-config/client/index.ts
var import_path_to_regexp = require("path-to-regexp");
var MicrofrontendConfigClient = class {
  constructor(config, opts) {
    this.pathCache = {};
    this.serialized = config;
    if (opts?.removeFlaggedPaths) {
      for (const app of Object.values(config.applications)) {
        if (app.routing) {
          app.routing = app.routing.filter((match) => !match.flag);
        }
      }
    }
    this.applications = config.applications;
  }
  /**
   * Create a new `MicrofrontendConfigClient` from a JSON string.
   * Config must be passed in to remain framework agnostic
   */
  static fromEnv(config, opts) {
    if (!config) {
      throw new Error("No microfrontends configuration found");
    }
    return new MicrofrontendConfigClient(
      JSON.parse(config),
      opts
    );
  }
  isEqual(other) {
    return JSON.stringify(this.applications) === JSON.stringify(other.applications);
  }
  getApplicationNameForPath(path6) {
    if (!path6.startsWith("/")) {
      throw new Error(`Path must start with a /`);
    }
    if (this.pathCache[path6]) {
      return this.pathCache[path6];
    }
    const pathname = new URL(path6, "https://example.com").pathname;
    for (const [name, application] of Object.entries(this.applications)) {
      if (application.routing) {
        for (const group of application.routing) {
          for (const childPath of group.paths) {
            const regexp = (0, import_path_to_regexp.pathToRegexp)(childPath);
            if (regexp.test(pathname)) {
              this.pathCache[path6] = name;
              return name;
            }
          }
        }
      }
    }
    const defaultApplication = Object.entries(this.applications).find(
      ([, application]) => application.default
    );
    if (!defaultApplication) {
      return null;
    }
    this.pathCache[path6] = defaultApplication[0];
    return defaultApplication[0];
  }
  serialize() {
    return this.serialized;
  }
};

// src/config/microfrontends-config/isomorphic/validation.ts
var import_path_to_regexp2 = require("path-to-regexp");
var validateConfigPaths = (applicationConfigsById) => {
  if (!applicationConfigsById) {
    return;
  }
  const pathsByApplicationId = /* @__PURE__ */ new Map();
  const errors = [];
  for (const [id, app] of Object.entries(applicationConfigsById)) {
    if (isDefaultApp(app)) {
      continue;
    }
    const childApp = app;
    for (const pathMatch of childApp.routing) {
      for (const path6 of pathMatch.paths) {
        const maybeError = validatePathExpression(path6);
        if (maybeError) {
          errors.push(maybeError);
        } else {
          const existing = pathsByApplicationId.get(path6);
          if (existing) {
            existing.applications.push(id);
          } else {
            pathsByApplicationId.set(path6, {
              applications: [id],
              matcher: (0, import_path_to_regexp2.pathToRegexp)(path6),
              applicationId: id
            });
          }
        }
      }
    }
  }
  const entries = Array.from(pathsByApplicationId.entries());
  for (const [path6, { applications: ids, matcher, applicationId }] of entries) {
    if (ids.length > 1) {
      errors.push(
        `Duplicate path "${path6}" for applications "${ids.join(", ")}"`
      );
    }
    for (const [
      matchPath,
      { applications: matchIds, applicationId: matchApplicationId }
    ] of entries) {
      if (path6 === matchPath) {
        continue;
      }
      if (applicationId === matchApplicationId) {
        continue;
      }
      if (matcher.test(matchPath)) {
        const source = `"${path6}" of application${ids.length > 0 ? "s" : ""} ${ids.join(", ")}`;
        const destination = `"${matchPath}" of application${matchIds.length > 0 ? "s" : ""} ${matchIds.join(", ")}`;
        errors.push(
          `Overlapping path detected between ${source} and ${destination}`
        );
      }
    }
  }
  if (errors.length) {
    throw new MicrofrontendError(`Invalid paths: ${errors.join(", ")}`, {
      type: "config",
      subtype: "conflicting_paths"
    });
  }
};
var PATH_DEFAULT_PATTERN = "[^\\/#\\?]+?";
function validatePathExpression(path6) {
  try {
    const tokens = (0, import_path_to_regexp2.parse)(path6);
    if (/(?<!\\)\{/.test(path6)) {
      return `Optional paths are not supported: ${path6}`;
    }
    if (/(?<!\\|\()\?/.test(path6)) {
      return `Optional paths are not supported: ${path6}`;
    }
    if (/\/[^/]*(?<!\\):[^/]*(?<!\\):[^/]*/.test(path6)) {
      return `Only one wildcard is allowed per path segment: ${path6}`;
    }
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === void 0) {
        return `token ${i} in ${path6} is undefined, this shouldn't happen`;
      }
      if (typeof token !== "string") {
        if (!token.name) {
          return `Only named wildcards are allowed: ${path6} (hint: add ":path" to the wildcard)`;
        }
        if (token.pattern !== PATH_DEFAULT_PATTERN && // Allows (a|b|c) and ((?!a|b|c).*) regex
        // Only limited regex is supported for now, due to performance considerations
        !/^(?<allowed>[\w]+(?:\|[^|()]+)+)$|^\(\?!(?<disallowed>[\w]+(?:\|[^|()]+)+)\)\.\*$/.test(
          token.pattern
        )) {
          return `Path ${path6} cannot use unsupported regular expression wildcard`;
        }
        if (token.modifier && i !== tokens.length - 1) {
          return `Modifier ${token.modifier} is not allowed on wildcard :${token.name} in ${path6}. Modifiers are only allowed in the last path component`;
        }
      }
    }
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    return `Path ${path6} could not be parsed into regexp: ${message}`;
  }
  return void 0;
}
var validateAppPaths = (name, app) => {
  for (const group of app.routing) {
    for (const p of group.paths) {
      if (p === "/") {
        continue;
      }
      if (p.endsWith("/")) {
        throw new MicrofrontendError(
          `Invalid path for application "${name}". ${p} must not end with a slash.`,
          { type: "application", subtype: "invalid_path" }
        );
      }
      if (!p.startsWith("/")) {
        throw new MicrofrontendError(
          `Invalid path for application "${name}". ${p} must start with a slash.`,
          { type: "application", subtype: "invalid_path" }
        );
      }
    }
  }
};
var validateConfigDefaultApplication = (applicationConfigsById) => {
  if (!applicationConfigsById) {
    return;
  }
  const applicationsWithRouting = Object.entries(applicationConfigsById).filter(
    ([, app]) => !isDefaultApp(app)
  );
  const applicationsWithRoutingNames = applicationsWithRouting.map(
    ([key]) => key
  );
  const numApplications = Object.keys(applicationConfigsById).length;
  const numApplicationsWithRouting = applicationsWithRoutingNames.length;
  const numApplicationsWithoutRouting = numApplications - numApplicationsWithRouting;
  if (numApplicationsWithoutRouting === 0) {
    throw new MicrofrontendError(
      "No default application found. At least one application needs to be the default by omitting routing.",
      { type: "config", subtype: "no_default_application" }
    );
  }
  if (numApplicationsWithoutRouting > 1) {
    throw new MicrofrontendError(
      `Only one application can omit "routing". Found ${applicationsWithRoutingNames.length - Object.keys(applicationConfigsById).length > 1}.`,
      { type: "config", subtype: "multiple_default_applications" }
    );
  }
};
var validateDeprecatedFields = (config) => {
  const errors = [];
  if (config.options?.vercel) {
    errors.push(
      `Configuration cannot contain deprecated field 'options.vercel'. Use 'options.disableOverrides' instead.`
    );
  }
  if (config.options?.localProxy) {
    errors.push(
      `Configuration cannot contain deprecated field 'options.localProxy'. Use 'options.localProxyPort' instead.`
    );
  }
  for (const [applicationId, application] of Object.entries(
    config.applications
  )) {
    if (application.vercel) {
      errors.push(
        `Application '${applicationId}' cannot contain deprecated field 'vercel'. Use 'projectId' instead.`
      );
    }
    if (application.production) {
      errors.push(
        `Application '${applicationId}' cannot contain deprecated field 'production'. Use 'development.fallback' instead.`
      );
    }
    if (application.development?.local) {
      errors.push(
        `Application '${applicationId}' cannot contain deprecated field 'development.local'. Use 'developement.localPort' instead.`
      );
    }
  }
  if (errors.length) {
    throw new MicrofrontendError(
      `Microfrontends configuration file errors:
- ${errors.join("\n- ")}`,
      {
        type: "config",
        subtype: "depcrecated_field"
      }
    );
  }
};

// src/config/microfrontends-config/isomorphic/utils/generate-asset-prefix.ts
var PREFIX = "vc-ap";
function generateAssetPrefixFromName({
  name
}) {
  if (!name) {
    throw new Error("Name is required to generate an asset prefix");
  }
  return `${PREFIX}-${name}`;
}

// src/config/microfrontends-config/isomorphic/utils/generate-port.ts
function generatePortFromName({
  name,
  minPort = 3e3,
  maxPort = 8e3
}) {
  if (!name) {
    throw new Error("Name is required to generate a port");
  }
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = (hash << 5) - hash + name.charCodeAt(i);
    hash |= 0;
  }
  hash = Math.abs(hash);
  const range = maxPort - minPort;
  const port = minPort + hash % range;
  return port;
}

// src/config/microfrontends-config/isomorphic/host.ts
var Host = class {
  constructor(hostConfig, options) {
    if (typeof hostConfig === "string") {
      ({
        protocol: this.protocol,
        host: this.host,
        port: this.port
      } = Host.parseUrl(hostConfig));
    } else {
      const { protocol = "https", host, port } = hostConfig;
      this.protocol = protocol;
      this.host = host;
      this.port = port;
    }
    this.local = options?.isLocal;
  }
  static parseUrl(url) {
    let hostToParse = url;
    if (!/^https?:\/\//.exec(hostToParse)) {
      hostToParse = `https://${hostToParse}`;
    }
    const parsed = new URL(hostToParse);
    if (!parsed.hostname) {
      throw new Error(Host.getMicrofrontendsError(url, "requires a host"));
    }
    if (parsed.hash) {
      throw new Error(
        Host.getMicrofrontendsError(url, "cannot have a fragment")
      );
    }
    if (parsed.username || parsed.password) {
      throw new Error(
        Host.getMicrofrontendsError(
          url,
          "cannot have authentication credentials (username and/or password)"
        )
      );
    }
    if (parsed.pathname !== "/") {
      throw new Error(Host.getMicrofrontendsError(url, "cannot have a path"));
    }
    if (parsed.search) {
      throw new Error(
        Host.getMicrofrontendsError(url, "cannot have query parameters")
      );
    }
    const protocol = parsed.protocol.slice(0, -1);
    return {
      protocol,
      host: parsed.hostname,
      port: parsed.port ? Number.parseInt(parsed.port) : void 0
    };
  }
  static getMicrofrontendsError(url, message) {
    return `Microfrontends configuration error: the URL ${url} in your microfrontends.json ${message}.`;
  }
  isLocal() {
    return this.local || this.host === "localhost" || this.host === "127.0.0.1";
  }
  toString() {
    const url = this.toUrl();
    return url.toString().replace(/\/$/, "");
  }
  toUrl() {
    const url = `${this.protocol}://${this.host}${this.port ? `:${this.port}` : ""}`;
    return new URL(url);
  }
};
var LocalHost = class extends Host {
  constructor({
    appName,
    localPort,
    ...hostConfig
  }) {
    const host = hostConfig.host ?? "localhost";
    const port = localPort ?? hostConfig.port ?? generatePortFromName({ name: appName });
    const protocol = hostConfig.protocol ?? "http";
    super({ protocol, host, port });
  }
};

// src/config/microfrontends-config/isomorphic/application.ts
var Application = class {
  constructor(name, {
    app,
    overrides,
    isDefault
  }) {
    this.name = name;
    this.development = {
      local: new LocalHost({
        appName: name,
        localPort: app.development?.localPort,
        ...app.development?.local
      }),
      fallback: app.development?.fallback ? new Host(app.development.fallback) : void 0
    };
    if (app.development?.fallback) {
      this.fallback = new Host(app.development.fallback);
    } else if (app.production) {
      this.fallback = new Host(app.production);
    }
    this.projectId = app.projectId ?? app.vercel?.projectId;
    this.overrides = overrides?.environment ? {
      environment: new Host(overrides.environment)
    } : void 0;
    this.default = isDefault ?? false;
    this.serialized = app;
  }
  isDefault() {
    return this.default;
  }
  getAssetPrefix() {
    return generateAssetPrefixFromName({ name: this.name });
  }
  serialize() {
    return this.serialized;
  }
};
var DefaultApplication = class extends Application {
  constructor(name, {
    app,
    overrides
  }) {
    super(name, {
      app,
      overrides,
      isDefault: true
    });
    this.default = true;
    const fallbackHost = app.development?.fallback ?? app.production;
    if (fallbackHost === void 0) {
      throw new Error(
        "`app.production` or `app.development.fallback` must be set in the default application in microfrontends.json."
      );
    }
    this.fallback = new Host(fallbackHost);
    if (app.production) {
      this.production = new Host(app.production);
    }
  }
  getAssetPrefix() {
    return "";
  }
};
var ChildApplication = class extends Application {
  constructor(name, {
    app,
    overrides
  }) {
    ChildApplication.validate(name, app);
    super(name, {
      app,
      overrides,
      isDefault: false
    });
    this.default = false;
    this.routing = app.routing;
  }
  static validate(name, app) {
    validateAppPaths(name, app);
  }
};

// src/config/microfrontends-config/isomorphic/constants.ts
var DEFAULT_LOCAL_PROXY_PORT = 3024;

// src/config/microfrontends-config/isomorphic/index.ts
var MicrofrontendConfigIsomorphic = class {
  constructor({
    config,
    overrides,
    meta,
    opts
  }) {
    this.childApplications = {};
    MicrofrontendConfigIsomorphic.validate(config, opts);
    const disableOverrides = config.options?.disableOverrides ?? config.options?.vercel?.disableOverrides ?? false;
    this.overrides = overrides && !disableOverrides ? overrides : void 0;
    this.isMainConfig = isMainConfig(config);
    if (isMainConfig(config)) {
      for (const [appId, appConfig] of Object.entries(config.applications)) {
        const appOverrides = !disableOverrides ? this.overrides?.applications[appId] : void 0;
        if (isDefaultApp(appConfig)) {
          this.defaultApplication = new DefaultApplication(appId, {
            app: appConfig,
            overrides: appOverrides
          });
        } else {
          this.childApplications[appId] = new ChildApplication(appId, {
            app: appConfig,
            overrides: appOverrides
          });
        }
      }
    } else {
      this.partOf = config.partOf;
      const appOverrides = !disableOverrides ? this.overrides?.applications[meta.fromApp] : void 0;
      this.childApplications[meta.fromApp] = new ChildApplication(
        meta.fromApp,
        {
          // we don't know routing because we're not in the main config
          app: { routing: [] },
          overrides: appOverrides
        }
      );
    }
    if (isMainConfig(config) && !this.defaultApplication) {
      throw new MicrofrontendError(
        "Could not find default application in microfrontends configuration",
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    this.config = config;
    this.options = config.options;
    this.serialized = {
      config,
      overrides,
      meta
    };
  }
  static validate(config, opts) {
    const skipValidation = opts?.skipValidation ?? [];
    const c = typeof config === "string" ? (0, import_jsonc_parser.parse)(config) : config;
    if (isMainConfig(c)) {
      validateConfigPaths(c.applications);
      validateConfigDefaultApplication(c.applications);
      if (!skipValidation.includes("deprecatedFields")) {
        validateDeprecatedFields(c);
      }
    }
    return c;
  }
  static fromEnv({
    meta,
    cookies
  }) {
    return new MicrofrontendConfigIsomorphic({
      config: (0, import_jsonc_parser.parse)(getConfigStringFromEnv()),
      overrides: parseOverrides(cookies ?? []),
      meta
    });
  }
  isOverridesDisabled() {
    return this.options?.vercel?.disableOverrides ?? false;
  }
  getConfig() {
    return this.config;
  }
  getApplicationsByType() {
    return {
      defaultApplication: this.defaultApplication,
      applications: Object.values(this.childApplications)
    };
  }
  getChildApplications() {
    return Object.values(this.childApplications);
  }
  getAllApplications() {
    return [
      this.defaultApplication,
      ...Object.values(this.childApplications)
    ].filter(Boolean);
  }
  getApplication(name) {
    if (this.defaultApplication?.name === name) {
      return this.defaultApplication;
    }
    const app = this.childApplications[name];
    if (!app) {
      throw new MicrofrontendError(
        `Could not find microfrontends configuration for application "${name}"`,
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    return app;
  }
  getApplicationByProjectId(projectId) {
    if (this.defaultApplication?.projectId === projectId) {
      return this.defaultApplication;
    }
    return Object.values(this.childApplications).find(
      (app) => app.projectId === projectId
    );
  }
  /**
   * Returns the default application. This can throw if the default application
   * is undefined ( )
   */
  getDefaultApplication() {
    if (!this.defaultApplication) {
      throw new MicrofrontendError(
        "Could not find default application in microfrontends configuration",
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    return this.defaultApplication;
  }
  /**
   * Returns the configured port for the local proxy
   */
  getLocalProxyPort() {
    return this.config.options?.localProxyPort ?? this.config.options?.localProxy?.port ?? DEFAULT_LOCAL_PROXY_PORT;
  }
  /**
   * Serializes the class back to the Schema type.
   *
   * NOTE: This is used when writing the config to disk and must always match the input Schema
   */
  toSchemaJson() {
    return this.serialized.config;
  }
  toClientConfig() {
    const applications = Object.fromEntries(
      Object.entries(this.childApplications).map(([name, application]) => [
        name,
        {
          default: false,
          routing: application.routing
        }
      ])
    );
    if (this.defaultApplication) {
      applications[this.defaultApplication.name] = {
        default: true
      };
    }
    return new MicrofrontendConfigClient({
      applications
    });
  }
  serialize() {
    return this.serialized;
  }
};

// src/config/microfrontends-config/isomorphic/child.ts
var MicrofrontendChildConfig = class extends MicrofrontendConfigIsomorphic {
  constructor({
    config,
    overrides,
    meta
  }) {
    super({ config, overrides, meta });
    this.isMainConfig = false;
    this.partOf = config.partOf;
  }
};

// src/config/microfrontends-config/isomorphic/main.ts
var MicrofrontendMainConfig = class extends MicrofrontendConfigIsomorphic {
  constructor({
    config,
    overrides,
    meta
  }) {
    super({ config, overrides, meta });
    this.isMainConfig = true;
    const disableOverrides = config.options?.disableOverrides ?? config.options?.vercel?.disableOverrides ?? false;
    let defaultApplication;
    for (const [appId, appConfig] of Object.entries(config.applications)) {
      const appOverrides = !disableOverrides ? this.overrides?.applications[appId] : void 0;
      if (isDefaultApp(appConfig)) {
        defaultApplication = new DefaultApplication(appId, {
          app: appConfig,
          overrides: appOverrides
        });
      } else {
        this.childApplications[appId] = new ChildApplication(appId, {
          app: appConfig,
          overrides: appOverrides
        });
      }
    }
    if (!defaultApplication) {
      throw new MicrofrontendError(
        "Could not find default application in microfrontends configuration",
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    this.defaultApplication = defaultApplication;
  }
};

// src/config/microfrontends/isomorphic/index.ts
var Microfrontends = class {
  constructor({
    config,
    overrides,
    meta
  }) {
    if (isMainConfig(config)) {
      this.config = new MicrofrontendMainConfig({ config, overrides, meta });
    } else {
      this.config = new MicrofrontendChildConfig({ config, overrides, meta });
    }
  }
  isChildConfig() {
    return this.config instanceof MicrofrontendChildConfig;
  }
  static fromEnv({
    cookies,
    meta
  }) {
    const config = MicrofrontendConfigIsomorphic.fromEnv({
      cookies,
      meta
    });
    return new Microfrontends(config.serialize());
  }
};

// src/config/microfrontends/utils/find-repository-root.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
var GIT_DIRECTORY = ".git";
function findRepositoryRoot(startDir) {
  if (process.env.NX_WORKSPACE_ROOT) {
    return process.env.NX_WORKSPACE_ROOT;
  }
  let currentDir = startDir || process.cwd();
  while (currentDir !== import_node_path.default.parse(currentDir).root) {
    const gitPath = import_node_path.default.join(currentDir, GIT_DIRECTORY);
    if (import_node_fs.default.existsSync(gitPath) && import_node_fs.default.statSync(gitPath).isDirectory()) {
      return currentDir;
    }
    currentDir = import_node_path.default.dirname(currentDir);
  }
  throw new Error(
    "Repository root not found. Specify the root of the repository with the `repository.root` option."
  );
}

// src/config/microfrontends/utils/find-package-path.ts
var import_node_path2 = require("path");
var import_node_fs2 = require("fs");
var import_fast_glob = __toESM(require("fast-glob"), 1);
var configCache = {};
function findPackagePathWithGlob({
  repositoryRoot,
  name
}) {
  try {
    const packageJsonPaths = import_fast_glob.default.globSync("**/package.json", {
      cwd: repositoryRoot,
      absolute: true,
      onlyFiles: true,
      followSymbolicLinks: false,
      ignore: ["**/node_modules/**", "**/.git/**"]
    });
    const matchingPaths = [];
    for (const packageJsonPath2 of packageJsonPaths) {
      const packageJsonContent = (0, import_node_fs2.readFileSync)(packageJsonPath2, "utf-8");
      const packageJson = JSON.parse(packageJsonContent);
      if (packageJson.name === name) {
        matchingPaths.push(packageJsonPath2);
      }
    }
    if (matchingPaths.length > 1) {
      throw new Error(
        `Found multiple packages with the name "${name}" in the repository: ${matchingPaths.join(", ")}`
      );
    }
    if (matchingPaths.length === 0) {
      throw new Error(
        `Could not find package with the name "${name}" in the repository`
      );
    }
    const [packageJsonPath] = matchingPaths;
    return (0, import_node_path2.dirname)(packageJsonPath);
  } catch (error) {
    return null;
  }
}
function findPackagePath(opts) {
  const cacheKey = `${opts.repositoryRoot}-${opts.name}`;
  if (configCache[cacheKey]) {
    return configCache[cacheKey];
  }
  const result = findPackagePathWithGlob(opts);
  if (!result) {
    throw new Error(
      `Could not find package with the name "${opts.name}" in the repository`
    );
  }
  configCache[cacheKey] = result;
  return result;
}

// src/config/microfrontends/utils/find-default-package.ts
var import_node_path3 = require("path");
var import_node_fs3 = require("fs");
var import_jsonc_parser2 = require("jsonc-parser");
var import_fast_glob2 = __toESM(require("fast-glob"), 1);

// src/config/constants.ts
var CONFIGURATION_FILENAMES = [
  "microfrontends.jsonc",
  "microfrontends.json"
];

// src/config/microfrontends/utils/find-default-package.ts
var configCache2 = {};
function findDefaultMicrofrontendsPackages({
  repositoryRoot,
  applicationName
}) {
  try {
    const microfrontendsJsonPaths = import_fast_glob2.default.globSync(
      `**/{${CONFIGURATION_FILENAMES.join(",")}}`,
      {
        cwd: repositoryRoot,
        absolute: true,
        onlyFiles: true,
        followSymbolicLinks: false,
        ignore: ["**/node_modules/**", "**/.git/**"]
      }
    );
    const matchingPaths = [];
    for (const microfrontendsJsonPath of microfrontendsJsonPaths) {
      try {
        const microfrontendsJsonContent = (0, import_node_fs3.readFileSync)(
          microfrontendsJsonPath,
          "utf-8"
        );
        const microfrontendsJson = (0, import_jsonc_parser2.parse)(microfrontendsJsonContent);
        if (isMainConfig(microfrontendsJson) && microfrontendsJson.applications[applicationName]) {
          matchingPaths.push(microfrontendsJsonPath);
        }
      } catch (error) {
      }
    }
    if (matchingPaths.length > 1) {
      throw new Error(
        `Found multiple default applications referencing "${applicationName}" in the repository, this is not yet supported.
${matchingPaths.join("\n  \u2022 ")}`
      );
    }
    if (matchingPaths.length === 0) {
      throw new Error(
        `Could not find default application with "applications.${applicationName}"`
      );
    }
    const [packageJsonPath] = matchingPaths;
    return (0, import_node_path3.dirname)(packageJsonPath);
  } catch (error) {
    return null;
  }
}
function findDefaultMicrofrontendsPackage(opts) {
  const cacheKey = `${opts.repositoryRoot}-${opts.applicationName}`;
  if (configCache2[cacheKey]) {
    return configCache2[cacheKey];
  }
  const result = findDefaultMicrofrontendsPackages(opts);
  if (!result) {
    throw new Error(
      "Error trying to resolve the main microfrontends configuration"
    );
  }
  configCache2[cacheKey] = result;
  return result;
}

// src/config/microfrontends/utils/is-monorepo.ts
var import_node_fs4 = __toESM(require("fs"), 1);
var import_node_path4 = __toESM(require("path"), 1);
function isMonorepo({
  repositoryRoot
}) {
  try {
    if (import_node_fs4.default.existsSync(import_node_path4.default.join(repositoryRoot, "pnpm-workspace.yaml"))) {
      return true;
    }
    if (import_node_fs4.default.existsSync(import_node_path4.default.join(repositoryRoot, "vlt-workspaces.json"))) {
      return true;
    }
    if (process.env.NX_WORKSPACE_ROOT === import_node_path4.default.resolve(repositoryRoot)) {
      return true;
    }
    const packageJsonPath = import_node_path4.default.join(repositoryRoot, "package.json");
    if (!import_node_fs4.default.existsSync(packageJsonPath)) {
      return false;
    }
    const packageJson = JSON.parse(
      import_node_fs4.default.readFileSync(packageJsonPath, "utf-8")
    );
    return packageJson.workspaces !== void 0;
  } catch (error) {
    console.error("Error determining if repository is a monorepo", error);
    return false;
  }
}

// src/config/microfrontends/utils/find-package-root.ts
var import_node_fs5 = __toESM(require("fs"), 1);
var import_node_path5 = __toESM(require("path"), 1);
var PACKAGE_JSON = "package.json";
function findPackageRoot(startDir) {
  let currentDir = startDir || process.cwd();
  while (currentDir !== import_node_path5.default.parse(currentDir).root) {
    const pkgJsonPath = import_node_path5.default.join(currentDir, PACKAGE_JSON);
    if (import_node_fs5.default.existsSync(pkgJsonPath)) {
      return currentDir;
    }
    currentDir = import_node_path5.default.dirname(currentDir);
  }
  throw new Error(
    "Package root not found. Specify the root of the package with the `package.root` option."
  );
}

// src/config/microfrontends/utils/find-config.ts
var import_node_fs6 = __toESM(require("fs"), 1);
var import_node_path6 = require("path");
function findConfig({ dir }) {
  for (const filename of CONFIGURATION_FILENAMES) {
    const maybeConfig = (0, import_node_path6.join)(dir, filename);
    if (import_node_fs6.default.existsSync(maybeConfig)) {
      return maybeConfig;
    }
  }
  return null;
}

// src/config/microfrontends/utils/get-application-context.ts
var import_node_fs7 = __toESM(require("fs"), 1);
var import_node_path7 = __toESM(require("path"), 1);
function getApplicationContext(opts) {
  if (opts?.appName) {
    return { name: opts.appName };
  }
  if (process.env.NX_TASK_TARGET_PROJECT) {
    return { name: process.env.NX_TASK_TARGET_PROJECT };
  }
  try {
    const packageJsonString = import_node_fs7.default.readFileSync(
      import_node_path7.default.join(opts?.packageRoot || ".", "package.json"),
      "utf-8"
    );
    const packageJson = JSON.parse(packageJsonString);
    if (!packageJson.name) {
      throw new MicrofrontendError(
        `package.json file missing required field "name"`,
        {
          type: "packageJson",
          subtype: "missing_field_name",
          source: "@vercel/microfrontends/next"
        }
      );
    }
    return { name: packageJson.name };
  } catch (err) {
    throw MicrofrontendError.handle(err, {
      fileName: "package.json"
    });
  }
}

// src/config/microfrontends/server/utils/get-output-file-path.ts
var import_node_path8 = __toESM(require("path"), 1);

// src/config/microfrontends/server/constants.ts
var MFE_CONFIG_DEFAULT_FILE_PATH = "microfrontends";
var MFE_CONFIG_DEFAULT_FILE_NAME = "microfrontends.json";

// src/config/microfrontends/server/utils/get-output-file-path.ts
function getOutputFilePath() {
  return import_node_path8.default.join(MFE_CONFIG_DEFAULT_FILE_PATH, MFE_CONFIG_DEFAULT_FILE_NAME);
}

// src/config/microfrontends/server/validation.ts
var import_jsonc_parser3 = require("jsonc-parser");
var import_ajv = require("ajv");

// schema/schema.json
var schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $ref: "#/definitions/Config",
  definitions: {
    Config: {
      anyOf: [
        {
          $ref: "#/definitions/MainConfig"
        },
        {
          $ref: "#/definitions/ChildConfig"
        }
      ]
    },
    MainConfig: {
      type: "object",
      properties: {
        $schema: {
          type: "string"
        },
        version: {
          type: "string",
          const: "1"
        },
        options: {
          $ref: "#/definitions/Options"
        },
        applications: {
          $ref: "#/definitions/ApplicationRouting",
          description: "Mapping of application names to the routes that they host. Only needs to be defined in the application that owns the primary microfrontend domain"
        }
      },
      required: ["applications"],
      additionalProperties: false
    },
    Options: {
      type: "object",
      properties: {
        vercel: {
          $ref: "#/definitions/VercelOptions",
          description: "Microfrontends wide options for Vercel.",
          deprecated: "This is being replaced by the `disableOverrides` field below."
        },
        disableOverrides: {
          type: "boolean",
          description: "If you want to disable the overrides for the site. For example, if you are managing rewrites between applications externally, you may wish to disable the overrides on the toolbar as they will have no effect."
        },
        localProxy: {
          $ref: "#/definitions/LocalProxyOptions",
          description: "Options for local proxy.",
          deprecated: "This is being replaced by the `localProxyPort` field below."
        },
        localProxyPort: {
          type: "number",
          description: "The port number used by the local proxy server.\n\nThe default is `3024`."
        }
      },
      additionalProperties: false
    },
    VercelOptions: {
      type: "object",
      properties: {
        disableOverrides: {
          type: "boolean",
          description: "If you want to disable the overrides for the site. For example, if you are managing rewrites between applications externally, you may wish to disable the overrides on the toolbar as they will have no effect."
        }
      },
      additionalProperties: false
    },
    LocalProxyOptions: {
      type: "object",
      properties: {
        port: {
          type: "number",
          description: "The port number used by the local proxy server.\n\nThe default is `3024`."
        }
      },
      additionalProperties: false
    },
    ApplicationRouting: {
      type: "object",
      additionalProperties: {
        $ref: "#/definitions/Application"
      },
      propertyNames: {
        description: "The unique identifier for a Microfrontend Application. Must match the `name` field of the application's `package.json`."
      }
    },
    Application: {
      anyOf: [
        {
          $ref: "#/definitions/DefaultApplication"
        },
        {
          $ref: "#/definitions/ChildApplication"
        }
      ]
    },
    DefaultApplication: {
      type: "object",
      properties: {
        vercel: {
          $ref: "#/definitions/Vercel",
          deprecated: "This is being replaced by the `projectId` field below."
        },
        projectId: {
          type: "string",
          description: "Vercel project ID"
        },
        production: {
          $ref: "#/definitions/HostConfig",
          deprecated: "This is a duplicate of the `development.fallback` field and this will be removed soon."
        },
        development: {
          $ref: "#/definitions/Development"
        }
      },
      additionalProperties: false
    },
    Vercel: {
      type: "object",
      properties: {
        projectId: {
          type: "string",
          description: "Vercel project ID"
        }
      },
      required: ["projectId"],
      additionalProperties: false
    },
    HostConfig: {
      type: "object",
      properties: {
        protocol: {
          type: "string",
          enum: ["http", "https"],
          description: "The protocol to be used for the connection.\n- `http`: Hypertext Transfer Protocol (HTTP).\n- `https`: Secure Hypertext Transfer Protocol (HTTPS).\n\n*"
        },
        host: {
          type: "string",
          description: "The hostname or IP address of the server. This can be a domain name (e.g., `example.com`) or an IP address (e.g., `192.168.1.1`)."
        },
        port: {
          type: "number",
          description: "The port number to be used for the connection. Common values include `80` for HTTP and `443` for HTTPS."
        }
      },
      required: ["host"],
      additionalProperties: false
    },
    Development: {
      type: "object",
      properties: {
        local: {
          $ref: "#/definitions/LocalHostConfig",
          deprecated: "This is being replaced by the `localPort` field below."
        },
        localPort: {
          type: "number",
          description: "The local port number that this application runs on when it is running locally. Common values include `80` for HTTP and `443` for HTTPS."
        },
        fallback: {
          anyOf: [
            {
              $ref: "#/definitions/HostConfig"
            },
            {
              type: "string"
            }
          ],
          description: "Fallback for local development, could be a host config that points to any environment. If this is not provided, or the application is not running - requests to the application in local development will error.\n\nIf passing a string, include the protocol (optional), host (required) and port (optional). For example: `https://this.ismyhost:8080`. If omitted, the protocol defaults to HTTPS. If omitted, the port defaults to `80` for HTTP and `443` for HTTPS."
        },
        task: {
          type: "string",
          description: "Optional task to run when starting the development server. Should reference a script in the package.json of the application."
        }
      },
      additionalProperties: false
    },
    LocalHostConfig: {
      type: "object",
      additionalProperties: false,
      properties: {
        host: {
          type: "string",
          description: "The hostname or IP address of the server. This can be a domain name (e.g., `example.com`) or an IP address (e.g., `192.168.1.1`)."
        },
        protocol: {
          type: "string",
          enum: ["http", "https"],
          description: "The protocol to be used for the connection.\n- `http`: Hypertext Transfer Protocol (HTTP).\n- `https`: Secure Hypertext Transfer Protocol (HTTPS).\n\n*"
        },
        port: {
          type: "number",
          description: "The port number to be used for the connection. Common values include `80` for HTTP and `443` for HTTPS."
        }
      }
    },
    ChildApplication: {
      type: "object",
      properties: {
        vercel: {
          $ref: "#/definitions/Vercel",
          deprecated: "This is being replaced by the `projectId` field below."
        },
        projectId: {
          type: "string",
          description: "Vercel project ID"
        },
        production: {
          $ref: "#/definitions/HostConfig",
          deprecated: "This is a duplicate of the `development.fallback` field and this will be removed soon."
        },
        development: {
          $ref: "#/definitions/Development"
        },
        routing: {
          $ref: "#/definitions/Routing",
          description: "Groups of path expressions that are routed to this application."
        }
      },
      required: ["routing"],
      additionalProperties: false
    },
    Routing: {
      type: "array",
      items: {
        $ref: "#/definitions/PathGroup"
      }
    },
    PathGroup: {
      type: "object",
      properties: {
        group: {
          type: "string",
          description: "Optional group name for the paths"
        },
        flag: {
          type: "string",
          description: "flag name that can be used to enable/disable all paths in the group"
        },
        paths: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      required: ["paths"],
      additionalProperties: false
    },
    ChildConfig: {
      type: "object",
      properties: {
        $schema: {
          type: "string"
        },
        version: {
          type: "string",
          const: "1"
        },
        options: {
          $ref: "#/definitions/Options"
        },
        partOf: {
          type: "string",
          description: "Applications that only serve a subset of the microfrontend routes only need to reference the name of the primary application that owns the full microfrontends configuration."
        }
      },
      required: ["partOf"],
      additionalProperties: false
    }
  }
};

// src/config/schema/utils/load.ts
var SCHEMA = schema_default;

// src/config/microfrontends/server/validation.ts
function filterAjvErrors(errors) {
  if (!errors) {
    return [];
  }
  return errors.filter((error) => {
    return error.keyword === "additionalProperties" || error.keyword === "required";
  });
}
function validateSchema(configString) {
  const parsedConfig = (0, import_jsonc_parser3.parse)(configString);
  const ajv = new import_ajv.Ajv();
  const validate = ajv.compile(SCHEMA);
  const isValid = validate(parsedConfig);
  if (!isValid) {
    throw new MicrofrontendError(
      `Invalid microfrontends config:
 - ${ajv.errorsText(filterAjvErrors(validate.errors), { separator: "\n - " })}

See https://openapi.vercel.sh/microfrontends.json for the schema.`,
      { type: "config", subtype: "does_not_match_schema" }
    );
  }
  return parsedConfig;
}

// src/config/microfrontends/server/index.ts
var MicrofrontendsServer = class extends Microfrontends {
  /**
   * Writes the configuration to a file.
   */
  writeConfig(opts = {
    pretty: true
  }) {
    const outputPath = getOutputFilePath();
    import_node_fs8.default.mkdirSync((0, import_node_path9.dirname)(outputPath), { recursive: true });
    import_node_fs8.default.writeFileSync(
      outputPath,
      JSON.stringify(
        this.config.toSchemaJson(),
        null,
        opts.pretty ?? true ? 2 : void 0
      )
    );
  }
  // --------- Static Methods ---------
  /**
   * Generates a MicrofrontendsServer instance from an unknown object.
   */
  static fromUnknown({
    config,
    cookies,
    meta
  }) {
    const overrides = cookies ? parseOverrides(cookies) : void 0;
    if (typeof config === "string") {
      return new MicrofrontendsServer({
        config: MicrofrontendsServer.validate(config),
        overrides,
        meta
      });
    }
    if (typeof config === "object") {
      return new MicrofrontendsServer({
        config,
        overrides,
        meta
      });
    }
    throw new MicrofrontendError(
      "Invalid config: must be a string or an object",
      { type: "config", subtype: "does_not_match_schema" }
    );
  }
  /**
   * Generates a MicrofrontendsServer instance from the environment.
   * Uses additional validation that is only available when in a node runtime
   */
  static fromEnv({
    cookies,
    meta
  }) {
    return new MicrofrontendsServer({
      config: MicrofrontendsServer.validate(getConfigStringFromEnv()),
      overrides: parseOverrides(cookies),
      meta
    });
  }
  /**
   * Validates the configuration against the JSON schema
   */
  static validate(config) {
    if (typeof config === "string") {
      const c = validateSchema(config);
      return c;
    }
    return config;
  }
  /**
   * Looks up the configuration by inferring the package root and looking for a microfrontends config file. If a file is not found,
   * it will look for a package in the repository with a microfrontends file that contains the current application
   * and use that configuration.
   *
   * This can return either a Child or Main configuration.
   */
  static infer({
    directory,
    filePath,
    meta,
    cookies,
    options
  } = {}) {
    if (filePath && meta) {
      return MicrofrontendsServer.fromFile({
        filePath,
        cookies,
        meta,
        options
      });
    }
    try {
      const packageRoot = findPackageRoot(directory);
      const { name: appName } = getApplicationContext({ packageRoot });
      const configMeta = meta ?? { fromApp: appName };
      const maybeConfig = findConfig({ dir: packageRoot });
      if (maybeConfig) {
        return MicrofrontendsServer.fromFile({
          filePath: maybeConfig,
          cookies,
          meta: configMeta,
          options
        });
      }
      const repositoryRoot = findRepositoryRoot();
      const isMonorepo2 = isMonorepo({ repositoryRoot });
      if (isMonorepo2) {
        const defaultPackage = findDefaultMicrofrontendsPackage({
          repositoryRoot,
          applicationName: appName
        });
        const maybeConfigFromDefault = findConfig({ dir: defaultPackage });
        if (maybeConfigFromDefault) {
          return MicrofrontendsServer.fromFile({
            filePath: maybeConfigFromDefault,
            cookies,
            meta: configMeta,
            options
          });
        }
      }
      throw new Error("Unable to infer");
    } catch (e) {
      throw new MicrofrontendError(
        "Unable to locate and parse microfrontends configuration",
        { cause: e, type: "config", subtype: "inference_failed" }
      );
    }
  }
  /*
   * Generates a MicrofrontendsServer instance from a file.
   */
  static fromFile({
    filePath,
    cookies,
    meta,
    options
  }) {
    try {
      const configJson = import_node_fs8.default.readFileSync(filePath, "utf-8");
      const config = MicrofrontendsServer.validate(configJson);
      if (!isMainConfig(config) && options?.resolveMainConfig) {
        const repositoryRoot = findRepositoryRoot();
        const isMonorepo2 = isMonorepo({ repositoryRoot });
        if (isMonorepo2) {
          const packagePath = findPackagePath({
            repositoryRoot,
            name: config.partOf
          });
          if (!packagePath) {
            throw new MicrofrontendError(
              `Could not find default application "${config.partOf}" in the repository`,
              { type: "config", subtype: "not_found" }
            );
          }
          const maybeConfig = findConfig({ dir: packagePath });
          if (!maybeConfig) {
            throw new MicrofrontendError(
              `Could not find microfrontends configuration in ${packagePath}`,
              { type: "config", subtype: "not_found" }
            );
          }
          return MicrofrontendsServer.fromMainConfigFile({
            filePath: maybeConfig,
            overrides: cookies ? parseOverrides(cookies) : void 0
          });
        }
      }
      return new MicrofrontendsServer({
        config,
        overrides: cookies ? parseOverrides(cookies) : void 0,
        meta
      });
    } catch (e) {
      throw MicrofrontendError.handle(e, {
        fileName: filePath
      });
    }
  }
  /*
   * Generates a MicrofrontendMainConfig instance from a file.
   */
  static fromMainConfigFile({
    filePath,
    overrides
  }) {
    try {
      const config = import_node_fs8.default.readFileSync(filePath, "utf-8");
      const validatedConfig = MicrofrontendsServer.validate(config);
      if (!isMainConfig(validatedConfig)) {
        throw new MicrofrontendError(
          `${filePath} is not a main microfrontend config`,
          {
            type: "config",
            subtype: "invalid_main_path"
          }
        );
      }
      const [defaultApplication] = Object.entries(validatedConfig.applications).filter(([, app]) => isDefaultApp(app)).map(([name]) => name);
      if (!defaultApplication) {
        throw new MicrofrontendError(
          "No default application found. At least one application needs to be the default by omitting routing.",
          { type: "config", subtype: "no_default_application" }
        );
      }
      return new MicrofrontendsServer({
        config: validatedConfig,
        overrides,
        meta: { fromApp: defaultApplication }
      });
    } catch (e) {
      throw MicrofrontendError.handle(e, {
        fileName: filePath
      });
    }
  }
};

// src/next/config/transforms/asset-prefix.ts
function transform(args) {
  const { next, app } = args;
  if (app.isDefault()) {
    return {
      next
    };
  }
  const assetPrefix = `/${app.getAssetPrefix()}`;
  if (next.assetPrefix !== void 0 && next.assetPrefix !== assetPrefix) {
    throw new Error(
      `"assetPrefix" already set and does not equal "${assetPrefix}". Either omit the assetPrefix in your next config, or set it to "${assetPrefix}".`
    );
  }
  next.assetPrefix = assetPrefix;
  return {
    next
  };
}

// src/next/config/transforms/build-id.ts
var import_nanoid = require("nanoid");
function transform2(args) {
  const { app, next, opts } = args;
  if (!opts?.supportPagesRouter) {
    return { next };
  }
  if (next.generateBuildId !== void 0) {
    throw new Error(
      '"generateBuildId" must not already be set in next.config.js when using microfrontends with "supportPagesRouter"'
    );
  }
  if (!app.isDefault()) {
    next.generateBuildId = () => {
      return `${app.getAssetPrefix()}-${(0, import_nanoid.nanoid)()}`;
    };
  }
  return {
    next
  };
}

// src/next/config/transforms/draft-mode.ts
function transform3(args) {
  const { next } = args;
  if (next.experimental?.multiZoneDraftMode !== void 0) {
    return {
      next
    };
  }
  next.experimental = next.experimental || {};
  next.experimental.multiZoneDraftMode = true;
  return {
    next
  };
}

// src/next/utils/route-to-local-proxy.ts
function routeToLocalProxy() {
  const isDevEnv = (process.env.VERCEL_ENV ?? "development") === "development";
  return isDevEnv && Boolean(process.env.TURBO_TASK_HAS_MFE_PROXY);
}

// src/next/config/transforms/redirects.ts
function transform4(args) {
  const { next, microfrontend, opts } = args;
  const isProduction2 = opts?.isProduction ?? false;
  const requireLocalProxyHeader = routeToLocalProxy() && !isProduction2 && !process.env.MFE_DISABLE_LOCAL_PROXY_REWRITE;
  if (requireLocalProxyHeader) {
    const proxyRedirects = [
      {
        source: "/:path*",
        destination: `http://localhost:${microfrontend.getLocalProxyPort()}/:path*`,
        permanent: false,
        missing: [{ type: "header", key: "x-vercel-mfe-local-proxy-origin" }]
      }
    ];
    if (next.redirects && typeof next.redirects === "function") {
      const originalRedirectsFn = next.redirects;
      next.redirects = async () => {
        const originalRedirects = await originalRedirectsFn();
        return [...proxyRedirects, ...originalRedirects];
      };
    } else {
      next.redirects = async () => proxyRedirects;
    }
  }
  return { next };
}

// src/routing/get-domain-from-environment.ts
function getDomainFromEnvironment({
  app,
  target
}) {
  const mfeProjects = JSON.parse(
    process.env.VERCEL_MICROFRONTENDS_PROJECTS ?? "[]"
  );
  if (mfeProjects.length === 0) {
    throw new Error("Missing related microfrontends project information");
  }
  if (!app.projectId) {
    throw new Error(`Missing applications[${app.name}].vercel.projectId`);
  }
  const vercelProject = mfeProjects.find((p) => p.project.id === app.projectId);
  if (!vercelProject) {
    throw new Error(
      `Missing related microfrontends project information for application "${app.name}"`
    );
  }
  const domain = target === "preview" && vercelProject.preview.branch ? vercelProject.preview.branch : vercelProject.production.alias ?? vercelProject.production.url;
  if (!domain) {
    throw new Error(
      `Missing domain for target "${target}" in application "${app.name}"`
    );
  }
  return domain.startsWith("https://") ? domain : `https://${domain}`;
}

// src/routing/get-domain-for-current-environment.ts
function debugDomains(zone, env, domain) {
  if (process.env.MFE_DEBUG === "true") {
    const indent = " ".repeat(4);
    const header = "domains (zone (env) -> domain)";
    const separator = "\u23AF".repeat(header.length);
    const line = `${indent} 1. ${zone} (${env}) -> ${domain}`;
    console.log(`${indent}${header}
${indent}${separator}
${line}
`);
  }
}
function getCurrentEnvironment() {
  const isDevelopment = !process.env.VERCEL_ENV || process.env.VERCEL_ENV === "development";
  const isPreview = process.env.VERCEL_ENV === "preview";
  const isProduction2 = process.env.VERCEL_ENV === "production";
  if (isDevelopment) {
    return { group: "development" };
  }
  if (isProduction2) {
    return { group: "production" };
  }
  if (isPreview) {
    return { group: "preview" };
  }
  return { group: "custom", name: process.env.VERCEL_ENV };
}
function getDomainForCurrentEnvironment(config, appName, opts = {}) {
  const app = config.getApplication(appName);
  if (!opts.ignoreOverride && app.overrides?.environment) {
    return app.overrides.environment.toString();
  }
  const { group } = getCurrentEnvironment();
  const fallbackHost = config.getDefaultApplication().fallback.toString();
  switch (group) {
    case "development": {
      const domain = ["test", "development"].includes(process.env.NODE_ENV) ? app.development.local.toString() : fallbackHost;
      debugDomains(appName, "development", domain);
      return domain;
    }
    case "preview": {
      return getDomainFromEnvironment({ app, target: "preview" });
    }
    case "production": {
      return getDomainFromEnvironment({ app, target: "production" });
    }
    case "custom":
      throw new Error(
        "Custom environments are not supported in getDomainForCurrentEnvironment"
      );
  }
}

// src/next/config/transforms/rewrites.ts
function debugRewrites(rewrites) {
  if (process.env.MFE_DEBUG === "true" || process.env.MFE_DEBUG === "1") {
    const indent = " ".repeat(4);
    const header = "rewrites (source \u2192 destination)";
    const separator = "\u23AF".repeat(header.length);
    const maxSourceLength = Math.max(
      ...rewrites.map((key) => key.source.length)
    );
    const table = rewrites.map((route, idx) => {
      const paddedSource = route.source.padEnd(maxSourceLength);
      return `${indent} ${idx + 1}. ${paddedSource} \u2192  ${route.destination}`;
    }).join("\n");
    console.log(`${indent}${header}
${indent}${separator}
${table}
`);
  }
}
function rewritesMapToArr(rewrites) {
  return Array.from(rewrites.entries()).flatMap(([source, rewrite]) => {
    const destination = `${rewrite.destination.domain || ""}${rewrite.destination.pathname}`;
    if (source === destination)
      return [];
    return [
      {
        source,
        destination
      }
    ];
  });
}
function transform5(args) {
  const { app, microfrontend, next, opts } = args;
  const buildBeforeFiles = () => {
    const rewrites = /* @__PURE__ */ new Map();
    if (!app.isDefault()) {
      rewrites.set(`/${app.getAssetPrefix()}/_next/:path+`, {
        destination: {
          pathname: "/_next/:path+"
        }
      });
      rewrites.set(`/${app.getAssetPrefix()}/.well-known/vercel/flags`, {
        destination: {
          pathname: "/.well-known/vercel/flags"
        }
      });
      rewrites.set(`/${app.getAssetPrefix()}/_vercel/:path*`, {
        destination: {
          pathname: "/_vercel/:path*"
        }
      });
    } else if (opts?.supportPagesRouter && !(microfrontend instanceof MicrofrontendChildConfig)) {
      for (const child of microfrontend.getChildApplications()) {
        rewrites.set(`/_next/data/${child.getAssetPrefix()}-:buildId/:path*`, {
          destination: {
            domain: getDomainForCurrentEnvironment(microfrontend, child.name),
            pathname: `/_next/data/${child.getAssetPrefix()}-:buildId/:path*`
          }
        });
      }
    }
    return rewritesMapToArr(rewrites);
  };
  const newBeforeFiles = buildBeforeFiles();
  if (next.rewrites && typeof next.rewrites === "function") {
    const originalRewritesFn = next.rewrites;
    next.rewrites = async () => {
      const originalRewrites = await originalRewritesFn();
      if (typeof originalRewrites === "object" && !Array.isArray(originalRewrites)) {
        const { beforeFiles = [] } = originalRewrites;
        return {
          beforeFiles: [...newBeforeFiles, ...beforeFiles],
          afterFiles: originalRewrites.afterFiles,
          fallback: originalRewrites.fallback
        };
      }
      return {
        beforeFiles: newBeforeFiles,
        afterFiles: originalRewrites,
        fallback: []
      };
    };
  } else {
    next.rewrites = async () => ({
      beforeFiles: newBeforeFiles,
      afterFiles: [],
      fallback: []
    });
  }
  debugRewrites(newBeforeFiles);
  return {
    next
  };
}

// src/next/config/transforms/server-actions.ts
function debugRewrites2(allowedOrigins) {
  if (process.env.MFE_DEBUG === "true" && allowedOrigins) {
    const indent = " ".repeat(4);
    const header = "server actions allowed origins";
    const separator = "\u23AF".repeat(header.length);
    const maxSourceLength = Math.max(
      ...allowedOrigins.map((key) => key.length)
    );
    const table = allowedOrigins.map((origin, idx) => {
      const paddedSource = origin.padEnd(maxSourceLength);
      return `${indent} ${idx + 1}. ${paddedSource}`;
    }).join("\n");
    console.log(`${indent}${header}
${indent}${separator}
${table}
`);
  }
}
var formatDomainForServerAction = (domain) => domain.replace(/https?:\/\//, "");
function transform6(args) {
  const { next, app, microfrontend } = args;
  if (microfrontend instanceof MicrofrontendChildConfig) {
    console.warn(
      "server actions transform requires the full config - skipping"
    );
    return {
      next
    };
  }
  const defaultApplication = microfrontend.getDefaultApplication();
  const appsToAllow = [
    // this zone - this is included by default unless allowedOrigins is overridden (which we are)
    // so we re-add it here.
    app,
    // this is the default zone for the microfrontend. Allow child zones to call server actions
    // that are in the default zone.
    defaultApplication
  ];
  const existingServerActionConfig = next.experimental?.serverActions;
  next.experimental = {
    ...next.experimental,
    serverActions: {
      ...existingServerActionConfig,
      allowedOrigins: Array.from(
        /* @__PURE__ */ new Set([
          // existing
          ...existingServerActionConfig?.allowedOrigins ?? [],
          // this deployments host
          ...process.env.VERCEL_URL ? [formatDomainForServerAction(process.env.VERCEL_URL)] : [],
          // default application host
          ...process.env.VERCEL_MICROFRONTENDS_PROJECTS ? [
            formatDomainForServerAction(
              getDomainFromEnvironment({
                app: defaultApplication,
                target: "production"
              })
            )
          ] : [],
          formatDomainForServerAction(defaultApplication.fallback.toString()),
          // environment specific microfrontend hosts
          ...appsToAllow.flatMap((a) => [
            formatDomainForServerAction(
              getDomainForCurrentEnvironment(microfrontend, a.name)
            )
          ])
        ])
      )
    }
  };
  debugRewrites2(next.experimental.serverActions?.allowedOrigins);
  return {
    next
  };
}

// src/next/config/transforms/webpack.ts
function transform7(args) {
  const { next, microfrontend, opts } = args;
  const configWithWebpack = {
    ...next,
    webpack(cfg, context) {
      const config = typeof next.webpack === "function" ? next.webpack(cfg, context) : cfg;
      const { isServer, nextRuntime, webpack: wpFromNext } = context;
      if (isServer || nextRuntime === "edge") {
        config.plugins.push(
          new wpFromNext.EnvironmentPlugin({
            MFE_CONFIG: JSON.stringify(microfrontend.serialize())
          })
        );
      }
      config.plugins.push(
        // Remove node: from import specifiers, because Next.js does not yet support node: scheme
        // https://github.com/vercel/next.js/issues/28774
        new wpFromNext.NormalModuleReplacementPlugin(
          /^node:/,
          (resource) => {
            resource.request = resource.request.replace(/^node:/, "");
          }
        )
      );
      if (!isServer) {
        config.resolve.fallback = {
          fs: false,
          path: false,
          crypto: false,
          ...config.resolve.fallback
        };
      }
      if (opts?.supportPagesRouter) {
        config.optimization.moduleIds = "deterministic";
        config.optimization.chunkIds = "deterministic";
        config.plugins.push({
          apply: (compiler) => {
            compiler.hooks.compilation.tap(
              "SortChunksPlugin",
              (compilation) => {
                compilation.hooks.optimizeChunks.tap(
                  "SortChunksPlugin",
                  (chunks) => {
                    const sortedChunks = Array.from(chunks).sort((a, b) => {
                      if (a.name && b.name) {
                        return a.name.localeCompare(b.name);
                      }
                      return (String(a.id) || "").localeCompare(
                        String(b.id) || ""
                      );
                    });
                    Array.from(chunks).forEach((chunk) => {
                      compilation.chunks.delete(chunk);
                    });
                    sortedChunks.forEach((chunk) => {
                      compilation.chunks.add(chunk);
                    });
                  }
                );
              }
            );
          }
        });
      }
      return config;
    }
  };
  return {
    next: configWithWebpack
  };
}

// src/next/config/transforms/index.ts
var transforms = {
  assetPrefix: transform,
  buildId: transform2,
  draftMode: transform3,
  redirects: transform4,
  rewrites: transform5,
  serverActions: transform6,
  webpack: transform7
};

// src/next/config/env.ts
function debugEnv(env) {
  if (process.env.MFE_DEBUG === "true") {
    const indent = " ".repeat(4);
    const header = "env (key \u2192 val)";
    const separator = "\u23AF".repeat(header.length);
    const maxKeyLength = Math.max(...Object.keys(env).map((key) => key.length));
    const table = Object.keys(env).map((key, idx) => {
      const paddedKey = key.padEnd(maxKeyLength);
      return `${indent} ${idx + 1}. ${paddedKey} =   ${env[key]}`;
    }).join("\n");
    console.log(`${indent}${header}
${indent}${separator}
${table}
`);
  }
}
function setEnvironment({
  app,
  microfrontends
}) {
  const clientEnvs = {
    NEXT_PUBLIC_MFE_CURRENT_APPLICATION: app.name,
    NEXT_PUBLIC_MFE_CLIENT_CONFIG: JSON.stringify(
      microfrontends.config.toClientConfig().serialize()
    ),
    ...process.env.ROUTE_OBSERVABILITY_TO_THIS_PROJECT && app.getAssetPrefix() ? {
      NEXT_PUBLIC_VERCEL_OBSERVABILITY_BASEPATH: `/${app.getAssetPrefix()}/_vercel`
    } : {}
  };
  const serverEnvs = {
    MFE_CURRENT_APPLICATION: app.name,
    MFE_CONFIG: JSON.stringify(microfrontends.config.getConfig())
  };
  const allEnvs = { ...clientEnvs, ...serverEnvs };
  for (const [key, value] of Object.entries(allEnvs)) {
    process.env[key] = value;
  }
  debugEnv(allEnvs);
}

// src/next/config/index.ts
function typedEntries(obj) {
  return Object.entries(obj);
}
function isProduction(opts) {
  if (opts?.isProduction) {
    return opts.isProduction();
  }
  return process.env.VERCEL_ENV === "production";
}
function withMicrofrontends(nextConfig, opts) {
  if (opts?.debug) {
    process.env.MFE_DEBUG = "true";
  }
  const { name: fromApp } = getApplicationContext(opts);
  const microfrontends = MicrofrontendsServer.infer({
    filePath: opts?.configPath,
    meta: {
      fromApp
    }
  });
  const app = microfrontends.config.getApplication(fromApp);
  setEnvironment({ app, microfrontends });
  let next = { ...nextConfig };
  for (const [key, transform8] of typedEntries(transforms)) {
    if (opts?.skipTransforms?.includes(key)) {
      console.log(`Skipping ${key} transform`);
      continue;
    }
    try {
      const transformedConfig = transform8({
        app,
        next,
        microfrontend: microfrontends.config,
        opts: {
          isProduction: isProduction(opts),
          supportPagesRouter: opts?.supportPagesRouter
        }
      });
      next = transformedConfig.next;
    } catch (e) {
      console.error("Error transforming next config", e);
      throw e;
    }
  }
  displayLocalProxyInfo(microfrontends.config.getLocalProxyPort());
  return next;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  withMicrofrontends
});
//# sourceMappingURL=config.cjs.map