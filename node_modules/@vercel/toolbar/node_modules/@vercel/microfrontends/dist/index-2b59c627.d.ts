import { H as HostConfig, L as LocalHostConfig, D as DefaultApplication$1, P as PathGroup, b as ChildApplication$1, c as Application$1, C as Config } from './index-2f78c0ca.js';
import { C as ClientConfig } from './types-4ef2bddb.js';
import { A as ApplicationOverrideConfig, O as OverridesConfig } from './types-b6d38aea.js';

interface MicrofrontendConfigClientOptions {
    removeFlaggedPaths?: boolean;
}
declare class MicrofrontendConfigClient {
    applications: ClientConfig['applications'];
    pathCache: Record<string, string>;
    private readonly serialized;
    constructor(config: ClientConfig, opts?: MicrofrontendConfigClientOptions);
    /**
     * Create a new `MicrofrontendConfigClient` from a JSON string.
     * Config must be passed in to remain framework agnostic
     */
    static fromEnv(config: string | undefined, opts?: MicrofrontendConfigClientOptions): MicrofrontendConfigClient;
    isEqual(other: MicrofrontendConfigClient): boolean;
    getApplicationNameForPath(path: string): string | null;
    serialize(): ClientConfig;
}

interface HostOptions {
    isLocal?: boolean;
}
declare class Host {
    protocol: 'http' | 'https';
    host: string;
    port?: number;
    local: boolean | undefined;
    constructor(hostConfig: HostConfig | string, options?: HostOptions);
    private static parseUrl;
    private static getMicrofrontendsError;
    isLocal(): boolean;
    toString(): string;
    toUrl(): URL;
}
/**
 * A Host subclass with defaults for locally running applications
 */
declare class LocalHost extends Host {
    constructor({ appName, localPort, ...hostConfig }: LocalHostConfig & {
        appName: string;
        localPort?: number;
    });
}

declare class Application {
    readonly default: boolean;
    name: string;
    development: {
        local: LocalHost;
        fallback?: Host;
    };
    fallback?: Host;
    projectId?: string;
    overrides?: {
        environment?: Host;
    };
    readonly serialized: Application$1;
    constructor(name: string, { app, overrides, isDefault, }: {
        app: Application$1;
        overrides?: ApplicationOverrideConfig;
        isDefault?: boolean;
    });
    isDefault(): boolean;
    getAssetPrefix(): string;
    serialize(): Application$1;
}
declare class DefaultApplication extends Application {
    readonly default = true;
    /** @deprecated use fallback instead. */
    production?: Host;
    fallback: Host;
    constructor(name: string, { app, overrides, }: {
        app: DefaultApplication$1;
        overrides?: ApplicationOverrideConfig;
    });
    getAssetPrefix(): string;
}
declare class ChildApplication extends Application {
    readonly default = false;
    routing: PathGroup[];
    constructor(name: string, { app, overrides, }: {
        app: ChildApplication$1;
        overrides?: ApplicationOverrideConfig;
    });
    static validate(name: string, app: ChildApplication$1): void;
}

interface ConfigMeta {
    /**
     * The application name that the configuration is being loaded from.
     */
    fromApp: string;
}
interface ValidationOptions {
    skipValidation?: 'deprecatedFields'[];
}
/**
 * A class to manage the microfrontends configuration.
 */
declare class MicrofrontendConfigIsomorphic {
    config: Config;
    isMainConfig: boolean;
    partOf?: string;
    defaultApplication?: DefaultApplication;
    childApplications: Record<string, ChildApplication>;
    overrides?: OverridesConfig;
    options?: Config['options'];
    private readonly serialized;
    constructor({ config, overrides, meta, opts, }: {
        config: Config;
        overrides?: OverridesConfig;
        meta: ConfigMeta;
        opts?: ValidationOptions;
    });
    static validate(config: string | Config, opts?: ValidationOptions): Config;
    static fromEnv({ meta, cookies, }: {
        meta: ConfigMeta;
        cookies?: {
            name: string;
            value: string;
        }[];
    }): MicrofrontendConfigIsomorphic;
    isOverridesDisabled(): boolean;
    getConfig(): Config;
    getApplicationsByType(): {
        defaultApplication?: DefaultApplication;
        applications: ChildApplication[];
    };
    getChildApplications(): ChildApplication[];
    getAllApplications(): (DefaultApplication | ChildApplication)[];
    getApplication(name: string): DefaultApplication | ChildApplication;
    getApplicationByProjectId(projectId: string): DefaultApplication | ChildApplication | undefined;
    /**
     * Returns the default application. This can throw if the default application
     * is undefined ( )
     */
    getDefaultApplication(): DefaultApplication;
    /**
     * Returns the configured port for the local proxy
     */
    getLocalProxyPort(): number;
    /**
     * Serializes the class back to the Schema type.
     *
     * NOTE: This is used when writing the config to disk and must always match the input Schema
     */
    toSchemaJson(): Config;
    toClientConfig(): MicrofrontendConfigClient;
    serialize(): {
        config: Config;
        overrides?: OverridesConfig;
        meta: ConfigMeta;
    };
}

export { ConfigMeta as C, DefaultApplication as D, MicrofrontendConfigIsomorphic as M };
